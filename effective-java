
1、考虑使用静态工厂方法代替构造方法【建议】
  优点
  ：
      a)工厂方法可以有自己的名字，会有语义的变化，方便阅读
      b)工厂方法不用每次被调用就返回一个新的对象
      c)工厂方法可以返回任何子类的对象
      java.util.Collections类的各种静态方法
      public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c) {
        return new UnmodifiableCollection<>(c);
      }
      d)返回的对象可以随调用的参数的同步而有不同的变化
       例：EnumSet的方法，根据数据返回不同的对象，64个以下的RegularEnumSet，64以上的JumboEnumSet实现
      /**
     * Creates an empty enum set with the specified element type.
     *
     * @param <E> The class of the elements in the set
     * @param elementType the class object of the element type for this enum
     *     set
     * @return An empty enum set of the specified type.
     * @throws NullPointerException if <tt>elementType</tt> is null
     */
    public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {
        Enum<?>[] universe = getUniverse(elementType);
        if (universe == null)
            throw new ClassCastException(elementType + " not an enum");

        if (universe.length <= 64)
            return new RegularEnumSet<>(elementType, universe);
        else
            return new JumboEnumSet<>(elementType, universe);
    }
    e)类中包含的方法不一定需要存在
      例如：jdbc一套的框架，只定义接口，实现留给客户端，服务提供框架一般需要满足3点，服务接口，服务注册API，服务获取API，以及可选的服务提供接口
      
  缺点
    a)没有public或者protected方法，不能被子类实例化
    b)不容易被编码者找到该方法
  工厂方法取名大概的列表：
    from, to, valueOf, intance/getInstance, create/newInstance, getType, newType, type等
    
2、当构造方法有多个参数时，考虑使用builder方法【建议】
  构造方法和静态工厂方法都有个缺点，不能在有多个可选参数时良好的工作，
  例：
   NutritionFacts cocaCola = new NutritionFacts();
   cocaCola.setServingSize(240);
   cocaCola.setServings(8);
   cocaCola.setCalories(100);
   cocaCola.setSodium(35);
   cocaCola.setCarbohydrate(27);
  上述对象初始化看着似乎比较简单，而且易读，但是会造成对象构造过程中出现状态不一致的情况
  NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)
           .calories(100).sodium(35).carbohydrate(27).build();
           
  类继承中的builder例子
  // Builder pattern for class hierarchies
public abstract class Pizza {
public enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUSAGE } final Set<Topping> toppings;
abstract static class Builder<T extends Builder<T>> { EnumSet<Topping> toppings = EnumSet.noneOf(Topping.class); public T addTopping(Topping topping) {
            toppings.add(Objects.requireNonNull(topping));
            return self();
}
         abstract Pizza build();
         // Subclasses must override this method to return "this"
         protected abstract T self();
      }
      Pizza(Builder<?> builder) {
         toppings = builder.toppings.clone(); // See Item 50
      }
}
  build模式一般在构造函数超过1手的时候比较适合采用

3、单例模式的构造【强制】
  a)私有构造方法加静态初始化
   // Singleton with static factory
  public class Elvis {
  private static final Elvis INSTANCE = new Elvis(); private Elvis() { ... }
  public static Elvis getInstance() { return INSTANCE; }
       public void leaveTheBuilding() { ... }
   }
 
  b)定义一个只有单个元素的Enum
  // Enum singleton - the preferred approach
   public enum Elvis {
       INSTANCE;
       public void leaveTheBuilding() { ... }
   }

 4、不需要实例化的类，添加一个私有的构造方法【强制】
  例:java.lang.Math
  
 5、宁愿依赖注入，不选硬编码【建议】
    简单的将依赖的资源传入构造方法
    // Dependency injection provides flexibility and testability
    public class SpellChecker {
       private final Lexicon dictionary;
       public SpellChecker(Lexicon dictionary) { this.dictionary = Objects.requireNonNull(dictionary);
        }
       public boolean isValid(String word) { ... }
       public List<String> suggestions(String typo) { ... }
    }
    上面的方法可以使用，但相对比较僵硬，如果传入一个工厂方法会很好
    Mosaic create(Supplier<? extends Tile> tileFactory) { ... }
    有多个资源和依赖，可以考虑static factory和builder的方式,将能获得灵活性、可重用、可测试的好处
    
  6、避免创建不必要的对象
     例：下面简单的对象创建，如果是在循环内部，会造成大量的新对象的创建
     String s = new String("bikini"); // DON'T DO THIS!
     对于可重用的、创建代价高昂的对象，
     
  7、消除废弃的对象引用
     无意识的保留废弃的对象引用，会出现隐藏的问题，
      a)它所引用的对象无法被gc所回收，并且废弃对象关联的所有对象同样如此
      b)废弃的引用可能被其它对象再次错误的引用
    解决方法：
     a)可以置为null，使gc能够回收这部分对象，并且错误的引用能够快速失败，
     何时去做这种操作，当一个类能够管理自己的内存时，就应该警惕这种内存泄露
     b)另一种常见的情况是缓存，当对象被缓存时，自身已经废弃了，缓存中的对象可能会被忘记，WeakHashMap可以达到这种效果，当map中的key的引用的对象
     已经废弃，map中的对象也将被释放
     c)
     
  8、避免使用finalizers和cleaners
    这两个方法的执行不能立刻执行，会带来不稳定和不可预期的结果
    
  9、try-with-resource优先于try-finally
    // try-with-resources - the the best way to close resources!
    static String firstLineOfFile(String path) throws IOException {
       try (BufferedReader br = new BufferedReader(
               new FileReader(path))) {
           return br.readLine();
     } }
    
    // try-with-resources on multiple resources - short and sweet
       static void copy(String src, String dst) throws IOException {
         try (InputStream   in = new FileInputStream(src);
              OutputStream out = new FileOutputStream(dst)) {
            byte[] buf = new byte[BUFFER_SIZE];
            int n;
            while ((n = in.read(buf)) >= 0)
            out.write(buf, 0, n);
            }
        }
     The resulting code is shorter and clearer, and the exceptions that it generates are more useful. 
     The try- with-resources statement makes it easy to write correct code using resources that must be closed, 
     which was practically impossible using try-finally.
     
 II.所有对象共有的方法
  10.重写equals方法时需要遵守一般的规则
    重写equals方法时，必须遵守它的一般约定。
    反身性:对于任何非空的引用值x,x.equals(x)必须返回true
    对称性:对于任何非空的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true
    传递性:对于任何非空的引用值x,y,z,如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)返回true
    一致性:对于任何非空的引用值x,y,对于没有修改值的情况下，多次调用x.equals(y)应该返回同样的结果
    对于所有非空的应用x,x.equals(null)必须返回false
    
    
    如果缺少这个类型检查，并且equals方法传递了一个错误类型的参数，那么equals方法将抛出一个ClassCastException，这违反了equals契约。
    但是instanceof操作符被指定为如果它的第一个操作数为null，则返回false，而不管第二个操作数[JLS, 15.20.2]中出现的是什么类型。
    
    一般写出一个好的equals方法需要遵守以下几点；
      * 如果被比较的对象是当前类的引用，可以使用==来校验，如果是的话，返回true，在比较代价比较大的时候，这一步操作是值得的
      * 使用 instanceof 来检查参数是否具有正确的类型，不是返回false
      * 将参数转换为正确的类型
      * 对于对象中每一个有意义的属性，都和参数中对象中相应的属性进行是否相等的判断比较，全部相等返回true，否则false
      
  11.当重写equals方法时，一定要重写hashCode方法
    如果不这样做，当使用到集合类的工具时，会出现错误的表现
    大概有以下三个一致的规范：
    * 当hashCode在同一个应用被对象多次重复调用时，在对象没有被改变值的情况下，每次应该返回相同的值，但是在应用不同的执行期间，不需要保持一致
    * 如果两个对象equals方法返回true的话，那么两个对象的hashcode方法应该返回相同的值
    * 如果两个对象equals返回false的话，不强制要求hashCode一定是不相同或相同，但是提供不同的值是可以提供对象的散列性能的
    
    一个好的hash方法会给不同的实例提供不同的哈希值，有一个简单的方法,分三步：
    * 定义一个result字段，将它初始化为第一个有意义字段的哈希值
    * 对剩余的所有有意义的字段按一下顺序逐个执行
      a:--计算一个属性的哈希值c
        a.1如果这个字段f是原始类型，调用它的包装类的Type.hashCode(f)方法,
        a.2如果字段是对象引用，并且这个对象的equals方法是通过递归调用比较的，那么递归调用每个字段上的hashCode方法，如果是更复杂的对象比较，
           则为该字段计算一个“规范表示”，并在规范表示上调用hashCode。如果字段的值为null，则使用0(或其他常数，但0是传统的)。
        a.3如果这个字段是个数组，那么对于每一个有意义的元素都是需要处理的，使用上一步的方式计算每一个元素的哈希值。如果数组中没有任何有意义的值，
          可以返回一个常量值（最好是非0）,如果数组中都是有意义的元素，可以是使用Arrays.hashCode(f[])对应参数的方法;
      b:合并每个字段的哈希值c到result，通过下面的公式
        result = 31 * result + c;
    * 返回最终的result
    
  12、总是覆盖toString方法
    在您编写的每个实例化类中重写Object的toString实现，除非超类已经这样做了。它使类更易于使用，并有助于调试。
    toString方法应该以美观的格式返回对象的简明、有用的描述。
    
  13、谨慎的覆盖clone方法
    
   // Copy constructor
   public Yum(Yum yum) { ... };
    A copy factory is the static factory (Item 1) analogue of a copy constructor:
   // Copy factory
   public static Yum newInstance(Yum yum) { ... };
   与Cloneable/clone相比，copy构造函数方法及其静态工厂变体有许多优点:它们不依赖于有风险倾向的超语言对象创建机制;
   他们不要求无法强制遵守几乎没有记录的约定;它们与正确使用final字段没有冲突;它们不会抛出不必要的检查异常;而且不需要转换。
   
   考虑到与Cloneable相关的所有问题，新的接口不应该扩展它，新的可扩展类不应该实现它。虽然实现Cloneable对最终类的危害较小，但这应该被看作是一种性能优化，
   只有在极少数情况下才需要这样做(第67项)。通常，复制功能最好由构造函数或工厂提供。此规则的一个重要例外是数组，最好使用克隆方法复制它。
   
   14、考虑实现comparable接口
   总之，无论何时实现具有合理排序的值类，都应该让该类实现Comparable接口，以便能够轻松地对其实例进行排序、搜索并在基于比较的集合中使用。在比较compareTo方法实现中的字段值时，要避免使用<和>操作符。
   相反，应该使用封装在原语类中的静态比较方法或比较器接口中的比较器构造方法。

   15、尽量减少类和成员的可访问性
   经验法则很简单:使每个类或成员尽可能不可访问。
   总而言之，您应该尽可能地减少程序元素的可访问性(在合理范围内)。在仔细设计了最小的公共API之后，您应该防止任何游离的类、接口或成员成为API的一部分。
   除了用作常量的公共静态final字段外，公共类应该没有公共字段。确保公共静态final字段引用的对象是不可变的。
   
   16、在public类中，使用接受器，不要使用public字段
   总之，公共类永远不应该公开可变字段。公共类公开不可变字段的危害要小一些，但仍然存在问题。
   但是，有时需要包私有或私有嵌套类来公开字段，无论是可变的还是不可变的。
    
   17、减少可变性
   不可变类简单来说就是一个类的实例不可以被修改
   得到一个不变类，遵循以下5个原则
   * 不提供可以修改字段的方法
   * 确保类不可以被继承
   * 确保所有字段都是final的
   * 确保所有字段都是private的
   * 确保对任何可变组件的独占访问
   
   一个不可变类的例子：
   // Immutable complex number class public final class Complex { private final double re; private final double im;
    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }
    public double realPart()      { return re; }
    public double imaginaryPart() { return im; }
    public Complex plus(Complex c) {
        return new Complex(re + c.re, im + c.im);
}
    public Complex minus(Complex c) {
        return new Complex(re - c.re, im - c.im);
}
    public Complex times(Complex c) {
        return new Complex(re * c.re - im * c.im,
                           re * c.im + im * c.re);
}
    public Complex dividedBy(Complex c) {
        double tmp = c.re * c.re + c.im * c.im;
        return new Complex((re * c.re + im * c.im) / tmp,
                           (im * c.re - re * c.im) / tmp);
}
    @Override public boolean equals(Object o) {
       if (o == this)
           return true;
       if (!(o instanceof Complex))
           return false;
       Complex c = (Complex) o;
// See page 47 to find out why we use compare instead of == return Double.compare(c.re, re) == 0
           && Double.compare(c.im, im) == 0;
    }
    @Override public int hashCode() {
        return 31 * Double.hashCode(re) + Double.hashCode(im);
    }
    @Override public String toString() {
        return "(" + re + " + " + im + "i)";
} }

  18、组合优先于继承
  在包中使用继承是安全的，在包中子类和超类实现由相同的程序员控制。在扩展为扩展而专门设计和记录的类时，使用继承也是安全的
  与方法调用不同，继承违反了封装
  继承只适用于子类确实是超类的子类型的情况。换句话说，只有当两个类之间存在“is-a”关系时，B类才应该扩展a类。
  总而言之，继承是强大的，但它是有问题的，因为它违反了封装。只有当子类和超类之间存在真正的子类型关系时，它才是合适的。
  即使这样，如果子类与超类在不同的包中，而超类不是为继承而设计的，继承也可能导致脆弱性。
  为了避免这种脆弱性，使用组合和转发而不是继承，特别是在存在实现包装类的适当接口时。包装器类不仅比子类更健壮，而且更强大。
 
  19.设计继承时需要文档话，否则禁止使用它
  测试为继承而设计的类的惟一方法是编写子类。
  总之，为继承设计类是一项艰巨的工作。您必须记录它的所有自我使用模式，并且一旦您记录了它们，您就必须在整个类的生命周期中致力于它们。
  如果不这样做，子类可能会依赖于超类的实现细节，如果超类的实现发生变化，子类可能会中断。
  为了允许其他人编写高效的子类，您可能还必须导出一个或多个受保护的方法。除非您知道确实需要子类，否则最好通过声明类final或确保没有可访问的构造函数来禁止继承。
  
  20.优先使用接口再考虑抽象类
  可以很容易地对现有类进行改造，以实现新的接口。
  接口是定义混合的理想方式
  接口允许构造非分层类型框架。
  接口通过包装每个类的习惯用法支持安全、强大的功能增强
  
  21、为后代设计接口
  java8接口支持默认方法实现
  在存在默认方法的情况下，接口的现有实现可能在编译时没有错误或警告，但在运行时失败。
  虽然这个问题并不常见，但也不是孤立的事件。已知Java 8中添加到集合接口的大量方法是易受影响的，已知有少量现有实现受影响。
  
  22、接口只用来定义类型
  当一个类实现了一个接口，这个接口可以作为一个类型，并作为实现它的类实例的引用。
  因此，若一个类实现了一个接口，则表明了客户端可以如何处理该类的实例。为其它目的来定义一个接口是不合适的。
  通过常量接口模式来使用接口是很糟糕的。会暴露类的常量的细节，同时也会污染接口的实现类
  总之，接口应该只被用来定义类型。它们不能仅仅是用来导出常量。

  23、优先考虑
