
1、考虑使用静态工厂方法代替构造方法【建议】
  优点
  ：
      a)工厂方法可以有自己的名字，会有语义的变化，方便阅读
      b)工厂方法不用每次被调用就返回一个新的对象
      c)工厂方法可以返回任何子类的对象
      java.util.Collections类的各种静态方法
      public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c) {
        return new UnmodifiableCollection<>(c);
      }
      d)返回的对象可以随调用的参数的同步而有不同的变化
       例：EnumSet的方法，根据数据返回不同的对象，64个以下的RegularEnumSet，64以上的JumboEnumSet实现
      /**
     * Creates an empty enum set with the specified element type.
     *
     * @param <E> The class of the elements in the set
     * @param elementType the class object of the element type for this enum
     *     set
     * @return An empty enum set of the specified type.
     * @throws NullPointerException if <tt>elementType</tt> is null
     */
    public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {
        Enum<?>[] universe = getUniverse(elementType);
        if (universe == null)
            throw new ClassCastException(elementType + " not an enum");

        if (universe.length <= 64)
            return new RegularEnumSet<>(elementType, universe);
        else
            return new JumboEnumSet<>(elementType, universe);
    }
    e)类中包含的方法不一定需要存在
      例如：jdbc一套的框架，只定义接口，实现留给客户端，服务提供框架一般需要满足3点，服务接口，服务注册API，服务获取API，以及可选的服务提供接口
      
  缺点
    a)没有public或者protected方法，不能被子类实例化
    b)不容易被编码者找到该方法
  工厂方法取名大概的列表：
    from, to, valueOf, intance/getInstance, create/newInstance, getType, newType, type等
    
2、当构造方法有多个参数时，考虑使用builder方法【建议】
  构造方法和静态工厂方法都有个缺点，不能在有多个可选参数时良好的工作，
  例：
   NutritionFacts cocaCola = new NutritionFacts();
   cocaCola.setServingSize(240);
   cocaCola.setServings(8);
   cocaCola.setCalories(100);
   cocaCola.setSodium(35);
   cocaCola.setCarbohydrate(27);
  上述对象初始化看着似乎比较简单，而且易读，但是会造成对象构造过程中出现状态不一致的情况
  NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)
           .calories(100).sodium(35).carbohydrate(27).build();
           
  类继承中的builder例子
  // Builder pattern for class hierarchies
public abstract class Pizza {
public enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUSAGE } final Set<Topping> toppings;
abstract static class Builder<T extends Builder<T>> { EnumSet<Topping> toppings = EnumSet.noneOf(Topping.class); public T addTopping(Topping topping) {
            toppings.add(Objects.requireNonNull(topping));
            return self();
}
         abstract Pizza build();
         // Subclasses must override this method to return "this"
         protected abstract T self();
      }
      Pizza(Builder<?> builder) {
         toppings = builder.toppings.clone(); // See Item 50
      }
}
  build模式一般在构造函数超过1手的时候比较适合采用

3、单例模式的构造【强制】
  a)私有构造方法加静态初始化
   // Singleton with static factory
  public class Elvis {
  private static final Elvis INSTANCE = new Elvis(); private Elvis() { ... }
  public static Elvis getInstance() { return INSTANCE; }
       public void leaveTheBuilding() { ... }
   }
 
  b)定义一个只有单个元素的Enum
  // Enum singleton - the preferred approach
   public enum Elvis {
       INSTANCE;
       public void leaveTheBuilding() { ... }
   }

 4、不需要实例化的类，添加一个私有的构造方法【强制】
  例:java.lang.Math
  
 5、宁愿依赖注入，不选硬编码【建议】
    简单的将依赖的资源传入构造方法
    // Dependency injection provides flexibility and testability
    public class SpellChecker {
       private final Lexicon dictionary;
       public SpellChecker(Lexicon dictionary) { this.dictionary = Objects.requireNonNull(dictionary);
        }
       public boolean isValid(String word) { ... }
       public List<String> suggestions(String typo) { ... }
    }
    上面的方法可以使用，但相对比较僵硬，如果传入一个工厂方法会很好
    Mosaic create(Supplier<? extends Tile> tileFactory) { ... }
    有多个资源和依赖，可以考虑static factory和builder的方式,将能获得灵活性、可重用、可测试的好处
    
  6、避免创建不必要的对象
     例：下面简单的对象创建，如果是在循环内部，会造成大量的新对象的创建
     String s = new String("bikini"); // DON'T DO THIS!
     对于可重用的、创建代价高昂的对象，
     
  7、消除废弃的对象引用
     无意识的保留废弃的对象引用，会出现隐藏的问题，
      a)它所引用的对象无法被gc所回收，并且废弃对象关联的所有对象同样如此
      b)废弃的引用可能被其它对象再次错误的引用
    解决方法：
     a)可以置为null，使gc能够回收这部分对象，并且错误的引用能够快速失败，
     何时去做这种操作，当一个类能够管理自己的内存时，就应该警惕这种内存泄露
     b)另一种常见的情况是缓存，当对象被缓存时，自身已经废弃了，缓存中的对象可能会被忘记，WeakHashMap可以达到这种效果，当map中的key的引用的对象
     已经废弃，map中的对象也将被释放
     c)
     
  8、避免使用finalizers和cleaners
    这两个方法的执行不能立刻执行，会带来不稳定和不可预期的结果
    
  9、try-with-resource优先于try-finally
    // try-with-resources - the the best way to close resources!
    static String firstLineOfFile(String path) throws IOException {
       try (BufferedReader br = new BufferedReader(
               new FileReader(path))) {
           return br.readLine();
     } }
    
    // try-with-resources on multiple resources - short and sweet
       static void copy(String src, String dst) throws IOException {
         try (InputStream   in = new FileInputStream(src);
              OutputStream out = new FileOutputStream(dst)) {
            byte[] buf = new byte[BUFFER_SIZE];
            int n;
            while ((n = in.read(buf)) >= 0)
            out.write(buf, 0, n);
            }
        }
     The resulting code is shorter and clearer, and the exceptions that it generates are more useful. 
     The try- with-resources statement makes it easy to write correct code using resources that must be closed, 
     which was practically impossible using try-finally.
     
 II.所有对象共有的方法
  10.重写equals方法时需要遵守一般的规则
    重写equals方法时，必须遵守它的一般约定。
    反身性:对于任何非空的引用值x,x.equals(x)必须返回true
    对称性:对于任何非空的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true
    传递性:对于任何非空的引用值x,y,z,如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)返回true
    一致性:对于任何非空的引用值x,y,对于没有修改值的情况下，多次调用x.equals(y)应该返回同样的结果
    对于所有非空的应用x,x.equals(null)必须返回false
    
    
    如果缺少这个类型检查，并且equals方法传递了一个错误类型的参数，那么equals方法将抛出一个ClassCastException，这违反了equals契约。
    但是instanceof操作符被指定为如果它的第一个操作数为null，则返回false，而不管第二个操作数[JLS, 15.20.2]中出现的是什么类型。
    
    一般写出一个好的equals方法需要遵守以下几点；
      * 如果被比较的对象是当前类的引用，可以使用==来校验，如果是的话，返回true，在比较代价比较大的时候，这一步操作是值得的
      * 使用 instanceof 来检查参数是否具有正确的类型，不是返回false
      * 将参数转换为正确的类型
      * 对于对象中每一个有意义的属性，都和参数中对象中相应的属性进行是否相等的判断比较，全部相等返回true，否则false
      
  11.当重写equals方法时，一定要重写hashCode方法
  
      

 
